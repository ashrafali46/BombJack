** V3.0 needs to be regenerated

* Audio board - Audio.pdsprj
	* BDD6502\src\main\java\com\bdd6502\AudioExpansion.java
	* Target 4 voices, for one channel output, 
	The 8K sample RAM can be populated using the output from C64\VideoHardware\target\debugData.txt
		* Done - Needs expansion to the full 64K
	* Audio registers, latches, are needed
		Starting to connect voice 0, the latches so far read the correct values
		All voice 0 latches work, loop mask and active mask also work
	* voiceInternalCounter[voice] += voiceRate[voice];
		with V0ST_ADDCOUNTER phase
	* voiceInternalCounter clear on voice inactive
	* TODO - voiceInternalChooseLoop will need the result of length comparison
	* HW: Note selective reset of only some adders when length is reached
	* Can use data: ..\C64\VideoHardware\target\debugData.txt
	* Or TestAudio1.txt
	* For comparison: http://www.ti.com/lit/ds/symlink/sn54s85.pdf?ts=1591365901295
		Comparison output works
		Now needs to process the result comparison at the appropriate time, after the output has a chance to be stable
			V0INTCOMPARELOOP latch works
			Need a suitable input to the counter latches
				V0ST_COMPARELENGTH	| VOICEACTIVEMASK0	| V0COMPISGE	| output
				0					| 0					| 0				| 0
				0					| 0					| 1				| 0
				0					| 1					| 0				| 1
				0					| 1					| 1				| 1
				1					| 0					| 0				| 0
				1					| 0					| 1				| 0
				1					| 1					| 0				| 1
				1					| 1					| 1				| 0
			https://www.dcode.fr/boolean-expressions-calculator
				Using: (!a && b && !c) || (!a && b && c) || (a && b && !c)
				Gives: (NOT a AND b) OR (b AND NOT c)
			Using the result in: https://www.dcode.fr/boolean-truth-table
				Matches my intended truth table
			Using digital data recording mode, output\DebugAudio.txt, with read on RAM read state, shows the counter values correctly counting

		Done - Need voicesActiveMask reset logic based on not looping
				V0ST_COMPARELENGTH	| _V0RESETCOUNTER	| VOICELOOPMASK0	| output
				0					| 0					| 0					| 1
				0					| 0					| 1					| 1
				0					| 1					| 0					| 1
				0					| 1					| 1					| 1
				1					| 0					| 0					| 0
				1					| 0					| 1					| 1
				1					| 1					| 0					| 1
				1					| 1					| 1					| 1
			(!a && !b && !c) || (!a && !b && c) || (!a && b && !c) || (!a && b && c) || (a && !b && c) || (a && b && !c) || (a && b && c)
			NOT a OR b OR c

		Done - Need address or loop address add to counter and memory read states
			V0ST_OUTPUTADDR
			V0ST_READRAM
			Created common adders for:
				COMMONADDRESS0..15
				COMMONPOSITION0..15
				COMMONREADADDRESS0..15
			TODO: Read debug and logic analyser indicates an incorrect value read for AUDA=4
				Perhaps the setup address time is not long enough?
				But reducing AUDCLK results in the RAMs not being written?!!
				d$00230002
				d$01c00003
			>>>>	d$01080004	Should be 0xff but reading 0x08???
				d$01730005
				d$01004020
			Why? With SAMP8 enabled in the simulation the RAM fails to write and read properly
				74245 is needed to isolate each RAM, it fixes the incorrect read
				The _OE,_WE, _CE is connected, just like all other RAMs for their respective banks
				_OE period has been reduced to only the time for address setup and read result
				_CE period has been reduced to only the time for address setup and read result, or EBS2 request time
				* This has fixed SAMP8 write issues and SAMPD read issues
					d$01230002
					d$01c00003
					d$01ff0004
					d$01730005
					d$01014020
					d$01024021
					d$01034022
					d$01014020
					d$01024021
					d$01034022

		* Done - Need to remove all unique voice internal terminals and group all unique voice input/output terminals for easier update

		Done - Need volume calculation, could be part of the common sample read module with a large EPROM
			This can simply cascade into the final output
			COMMONVOLUME0..7 created
			
		
		Done - And if not voice active then just output 0x80
			This could use the common logic from _VO_ADDRCNTOUT, when there is no RAM chip enabled at U1 (connected to _VO_ADDRCNTOUT and U52:C)
				This enables uses a latch and selector for the value to load into the final output after the volume calculation
				This uses AUDOE to combine detection for the sample RAM being written to and mutes the output when this happens

		
		* Need to create other voices

		And latch output of sample once for all four voices?
			Added extra step V0ST_OUTPUTADDR2 to allow V0ST_READRAM to be used for +ve edge trigger
			Cascade adders for sample?
			Then final output latch or 0xff read on carry detection for values > 0xff
		* At the end of a sample, without loop, does the MOD file player output a 0x80 or the last sample read?




* For the mode7 register latches, it might be better to only latch on the HH byte write, but this would use an additional 3*6 latches, which would be too much.
	This would allow updates at any point in the scanline, with the copper. At the moment a write to the l/h/hh registers cannot happen in one pixel clock so the added value will be partially updated and used.



* Perhaps a layer combination board, which does the zero 3-bit or 8 bit pixel test and allows multiple expansion planes to be used?



* Idea for new layer, scaled rotated sprites
	Setup sprite data x/y/dx/dxy/dy/dyx like mode7, plus a screen top left x/y plus width/height bounding box to iterate.
	It spits out pixels into the screen buffer and signals when it's done
	And could optionally hop into the next item in a link list... and signal the end of the link list
		the mode7 render got me thinking, because the circuitry only really differs in the "fetch a tile index from the screen memory" side of things
		So basically rendering a rotated quad outside the edges test becomes "is the X and Y tile position = 0" instead of "fetch tile index"
		If it's outside the edges then don't plot pixels


* Need a simple bottom left |_ tile, then position this in the four corners with suitable H/V flips to allow the maximum pixel extent to be validated
	Then validate the border shrinks




* Investigate the "display enable" being used to still output video timings, just disable the pixel output
	This would allow memory updates to be enabled, without seeing bad video output and while maintaining video sync




* C64 userport references
	Nice looking breakout board with reset button: https://www.tindie.com/products/syzygy_systems/c64-user-port-breakout-board-v11-syzygy-phobos/
	Just the connector: https://www.thefuturewas8bit.com/userport-connector.html
	Simple flashing LEDs example with code: https://coronax.wordpress.com/2012/08/11/the-commodore-64-user-port/
		
		



* Auto-routing tests
	With default options, it takes ~15 minutes: https://support.labcenter.com/forums/viewtopic.php?f=5&t=7693
	Are there quicker options?
		Yes, changing the grid does help but sometimes the boards are not populated fully as they run out of space.



* VSMDD2 why is "w$ff01ff00,$3f018000" triggering near raster 2f?
	* The copper (VSMDD2) RV[0..7] input needed an extra latching 74273 (U84 excluded from PCB) to smooth the signal from the counters
		This kind of buffering logic is going to be needed on the real hardware, and might need to be added to the VSMDD2 inputs from the CLK
* Below might be related...
* Colour bars: With the sin/cos wave pattern, it seems to clamp to a bad value? Investigate the data driving this pattern...
	The horizontal and vertical pixel counters might need to be latched



* GenerateData2
	* Is the slight pixel ripple effect observed when moving right (output\debug2.gif) is the hardware or the virtual display adaptor...
	* Much higher X resolutions (like 1024 pixels) on the virtual display need to be tested...
		* Higher resolutions do show the grass an other tiles with some very thin vertical colour edge bleeding on perhaps the tile boundary
			This might be due to the colour RAM fetch not being completely synced with the tile pixel shifting and output mix?
			Or this might be caused by the horizontal and vertical pixel clocks not being latched from the counters, so the counter ripple is not quite exactly settling all at the same time?





* Copper plans
	If the hires xpos is used, then consider starting a _MEWR pulse at that point in time and any further writes would be based on that time too.
	This would allow hires writes to the background colour for example.
	Any subsequent writes could then be lower resolution to fit with RAM timing constraints.
	Could the copper board be built in-between the 24 bit parallel board and the main display board?
		Input = EBS + EAB + EDB + ROWCOL, output = EBS + EAB + EDB
			Internally EBS = 2 is used to trigger the copper and ROWCOL checks
			It could use VIDCLK and 6MHz lines from ROWCOL
	Note: The selector and RAM are used to show working memory writes in the main display board
	* It would be possible to store a 16 bit addition value, to facilitate storage of screen data that is stored in values +16 bytes at a time



* Overscan, disable all pixel blanking from HBL?




* Need DigitalDisplay frame recording and verification of displayed frame with recorded frame.
	Pixel by pixel tests. Can display if the current frame as it is being built up matches the recording, or not.
	Highlight areas that don't match?
	
	

* Need the DigitalData model to also verify a recording against what it currently detects.
	It can also display if what it has received so far matches the recording.



* Need to update ReadMe to reflect new design



* Split design into layers, use common bus for internal communications
	* Renumber component refs depending on their layer, 1xx main, 2xx screen... etc.
	* Main: Clocking, video timing, pixel combination and palette lookups
	* Screen + colour RAM
	* Sprites
	* Background picture



* Note C5 200P capacitor, check it is a ceramic disc on the board



* Parts list, Book of Materials, stock code links to ordering websites needed
	Adding links to the "stock code"
	Breadboard
	https://www.mouser.sg/ProductDetail/Twin-Industries/TW-E41-1060?qs=sGAEpiMZZMvxYGX2LOb%252BCkpSd%2FF6Zib6rdOv%2FJq26CY%3D
	Resistors
	https://www.mouser.sg/Passive-Components/Resistors/Through-Hole-Resistors/_/N-7h7z5
	https://www.mouser.sg/Passive-Components/Resistors/Through-Hole-Resistors/_/N-7h7z5?P=1z0z819Z1yzbpodZ1yyxf87
	VGA
	https://www.mouser.sg/ProductDetail/Gravitech/DB15F-VGA-TERM?qs=%2Fha2pyFadujCKQleo0iutDpWDaGRRxjTkj9IAyF0Np7%252BUoWsr1SFIUxZNLIelf9qWe7mZLtJ2l3bbZy4VSVLAA%3D%3D
	SIL/DIL connectors
	https://www.mouser.sg/3M/Connectors/Headers-Wire-Housings/_/N-ay0lo?P=1z0xbxoZ1yvsm2aZ1yvgcdjZ1ytkn39Z1yq9ciwZ1ytkls2Z1ytkn06Z1z0z5h6Z1yzxj1jZ1z0z63xZ1z0wxp6Z1yzv7x1Z1z0zp4d
	Sockets decoupling
	https://www.digikey.sg/products/en/connectors-interconnects/sockets-for-ics-transistors/409?k=&pkeyword=dip+decoupling&sv=0&pv5=382168&sf=1&FV=589%7C405002%2C-8%7C409&quantity=&ColumnSort=0&page=1&pageSize=25
	Same decoupling socket, found using manufacturer part number
		https://www.digikey.com/product-detail/en/mill-max-manufacturing-corp/110-93-314-41-801000/ED2101-ND/33731
		https://www.mouser.sg/ProductDetail/Mill-Max/110-93-314-41-801000?qs=%2Fha2pyFaduiAoJI%252BFT3Un6AU4u1EPWQWyNo%252BHzE50tJ%252B9XjMyXXSECwGDt8yOlKj
	Digikey might be a better source?
		https://www.digikey.sg/products/en/integrated-circuits-ics/logic-gates-and-inverters/705?k=74ls27&k=&pkeyword=74ls27&sv=0&pv69=411897&sf=0&FV=-8%7C705&quantity=&ColumnSort=0&page=1&pageSize=25
		https://www.mouser.sg/ProductDetail/Texas-Instruments/SN74LS27N?qs=sGAEpiMZZMutXGli8Ay4kP28D9wZ8SQIwsPDjIqEADE%3D
	Digikey has memory
		https://www.digikey.sg/products/en/integrated-circuits-ics/memory/774?k=&pkeyword=&sv=0&pv69=411897&sf=1&FV=-8%7C774&quantity=&ColumnSort=0&page=1&pageSize=25
		But no price: https://www.digikey.sg/products/en/integrated-circuits-ics/memory/774?k=&pkeyword=&sv=0&pv142=227740&sf=1&FV=-8%7C774%2C69%7C411897&quantity=&ColumnSort=0&page=1&pageSize=25
		Jameco has: https://www.jameco.com/shop/ProductDisplay?catalogId=10001&langId=-1&storeId=10001&productId=38957
			Faster: https://www.jameco.com/z/2114N-2-Major-Brands-IC-2114N-2-SRAM-1Kx4-DIP-18-pin-200ns_38973.html?CID=MERCH


* Reorganise the memory map detection logic, remove 3M:A for ROMs, 3M:B 4M 5M 2S:B 1C:A
	Add new memory block detection for _9800CS, _9A00CS, _9C00CS, _9E00CS
	Use a memory block that is not used by the expansion RAM, perhaps the BASIC ROM area
	Check the CPU memory expansion, BUSDDR or CPUHASBUS can also be used to improve the memory block chip detection
	


* For integration with the TTL 8 bit CPU the VSYNC signal could be exposed to EXPANSIONBUS:EXTWANTIRQ
	Remove extra unused logic E7P:A E7P:B E6P:C 5P:A
	This will need a latch arrangement similar to the CPU latch, no use holding EXTWANTIRQ low for so long without being acked
	CPU->Root sheet 8->U250:A
		CIA1 read ACK U201:A



* Allow the _HSYNC and _VSYNC to be read via the external header, as memory mapped IO. Probably reuse the number of sprite register see _9A00CS
	This would need _MERD to be added to the external header. Also the BUSDDR would need to be used to enable the correct tri-state output
* Allow RH AND RV to be accessed via memory mapped IO
	
	
	



* The expansion bus and the memory write signals will need to be translated to the internal memory write signals




	
* 4C/4D when run at 6MHz will generate "sub optimal write pulses" errors with default values. Running at 1MHz fixes these issues.
	* The output pixel data seems to be better when the timing is reduced.
	* Investigate the output for read/write timings of these memory ICs for 6MHz operation.

	
	

* How many layers? Six?
	https://www.allpcb.com/6_layer_pcb.html
		Created template: All PCB Six Layer 1.58532mm.LTF
	http://referencedesigner.com/books/si/6-layer-stackup-ch6.php
	
	
* Singapore PCB fabrication:
	https://www.wizlogix.com/
	http://www.evonix.com.sg/PCBFabrication.php
	http://www.kentronicsengineering.com/
	



* All the very similar block, for the new RAMs and also the pixel shift outputs, could use a sub-circuit now
	Since they are RAM addressed and the ROM with its associated data file in the schematic is not important
	If the RAM/ROM names are still important, then have them outside of the sub-circuit



* Split this layout so that different output planes can be added or removed via internal headers, daisy-chained probably.
	The final combination logic can then take the output pixels and combine the final result via the pallet lookups
