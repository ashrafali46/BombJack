* When running at VIDCLK 6MHz, the target speed, the sprites fail to render correctly.
	This is because Root sheet 5 4A/4B/4C/4D/ have by default 200ns address access time.
	They are 4 bit RAMs, obviously the original hardware was slightly exceeding the 166.6 ns timing from the 6MHz clock
	Verified that if the default 200ns is changed to be 100ns then the sprites start displaying again
		* It is interesting to note 8K replacement 6264 RAMs are all 100ns address access time
	They only use A0-A7 internally
	Consider using 8 bit RAMs with lower access times instead
	The next viable RAM would be: https://www.jameco.com/z/6116P-70-Major-Brands-IC-6116P-70-CMOS-SRAM-16-384-Bit-2Kx8-70-ns_242675.html
		This can be simulated and it is still able to be ordered.
	Running a 12 MHz VIDCLK with 70ns address access time results in some corrupt sprites at their correct positions
		Running with 10 MHz VIDCLK (49.2 FPS) means the sprites render correctly.
		With 50ns address access time the sprites render correctly.
		(See Root sheet 5 with 6116 RAM for sprite spans for an example)
	* TODO: Split the 2114 RAMs into two or more, based on their low address, to interleave the bit accesses
		Might have to latch the address and data to hold the address and data for longer, have 2 or 4 latches?
		This latches will need to use the low address lines to decide which chip to enable for read/write
	http://www.cs.smith.edu/~jfrankli/270s02/datasheets/2114.html
		Note: No address setup time
	http://www.ukvac.com/forum/bomb-jack-pcb_topic368665.html
	* TODO: Study the memory, data and WE access patterns to plan for the best strategy
		From about 1.33 seconds into the simulation will be the middle of the frame
		Note: VSMDD3 on root sheet 5 setup to record the:
			Address
			Byte
			D24 _write
			D30 0 = Output pixel data to the screen and clear to ff, 1 = reading/writing sprites
			D31 _CE
			Clock start time 1.33
		Note: 4C4DRecording.txt
		Note: The first few thousand lines were trimmed to align with the start of the d$4 phase
		d$0 indicates _CE and outputting pixels to the screen
			So the following:
				d$0100ff08
				d$01006f08
				d$00006f08
				d$0000ff08
				d$0100ff09
				d$01006f09
				d$00006f09
				d$0000ff09
			Note the address counts up, reads, then quickly writes ff, note the data is not stable during the _WE
		d$4 indicates writing sprite data
			Using TestData.txt "Top left all the same" it's possible to see the same address range 0-f repeatedly being used
			4D (ID4-7) starts to get 77...
			4C (ID0-3) still shows ff...
			So the following:
				d$4100ff00
				d$4000ff00
				d$40007f00
				d$41007f01
				d$4100ff01
				d$4000ff01
				d$40007f01
			Indicates that the RAM will consume the written data even after the 6MHz negative edge, basically when it's low
				However note that the address is stable
		Perhaps on _WE, the relevant latching address hold and write hold can hold the WE low for the relevant RAM whilst the new address switches to its read mode
		Once the address switches to read mode the WE is not held low
		* In Test2114 project, using the 10MHz VSMDD3 recording only half of the bytes are visible in the 2114s
		* Now the VSMDD3 clock is at 100MHz, now the 2114s do show both halves are written to.
			It shows there is some high-frequency interaction going on that needs study.
			Which is visible in the recordings:
				d$0000ff00
				d$0100ff00
				d$0100ff01
				and
				d$40007f00
				d$41007f00
				d$41007f01
			Note the very quick (<10ns) write address 0, then read address 0, then read address 1
		* 4C4DRecording output pixels.txt
			Been created to start with pixel output and clear
		Note however the high frequency variance in address lines:
			d$41007f01
			d$41007f03 <<<
			d$41007f02
		Probably due to 6C/6D 74163 counters displaying a non-stable ripple output
			Solved by adding U77/U78 74273 that use _VIDCLK for CLK to latch the address inputs a short time after the counters have finished
			Note the recording now shows a stable address lagging behind 21/22 lines (210/220 ns) plenty of time for the signals to settle
			Visually the output sprite pixels do seem to be a little bit better formed, more regular
		https://www.mouser.sg/Semiconductors/Logic-ICs/Logic-Comparators/_/N-cbost?P=1z0y33v&Keyword=74ls688&FS=True
		* Test2114
			* TODO: If _6MHz (writing) and IDA0 then use memory, memory _WE needs to be held low for longer than _6MHz, enable write latch signal, also latch data to write to memory, also U2 load address and U9 load data, and output enable U9 for cached output
			* Done: If 6MHz (reading) and IDA0 and IDA=C0A then bypass memory and output enable U9
			* TODO: If 6MHz (reading) and IDA0 and IDA!=C0A then use memory, bypass U2 and U9, select raw memory signal 74257, reset any write latch for memory and output enable select memory

	


* Need DigitalDisplay frame recording and verification of displayed frame with recorded frame.
	Pixel by pixel tests. Can display if the current frame as it is being built up matches the recording, or not.
	Highlight areas that don't match?
	
	

* Need the DigitalData model to also verify a recording against what it currently detects.
	It can also display if what it has received so far matches the recording.



* Need to update ReadMe to reflect new design



* Split design into layers, use common bus for internal communications
	* Renumber component refs depending on their layer, 1xx main, 2xx screen... etc.
	* Main: Clocking, video timing, pixel combination and palette lookups
	* Screen + colour RAM
	* Sprites
	* Background picture



* Note C5 200P capacitor, check it is a ceramic disc on the board



* Parts list, Book of Materials, stock code links to ordering websites needed
	Adding links to the "stock code"
	Breadboard
	https://www.mouser.sg/ProductDetail/Twin-Industries/TW-E41-1060?qs=sGAEpiMZZMvxYGX2LOb%252BCkpSd%2FF6Zib6rdOv%2FJq26CY%3D
	Resistors
	https://www.mouser.sg/Passive-Components/Resistors/Through-Hole-Resistors/_/N-7h7z5
	https://www.mouser.sg/Passive-Components/Resistors/Through-Hole-Resistors/_/N-7h7z5?P=1z0z819Z1yzbpodZ1yyxf87
	VGA
	https://www.mouser.sg/ProductDetail/Gravitech/DB15F-VGA-TERM?qs=%2Fha2pyFadujCKQleo0iutDpWDaGRRxjTkj9IAyF0Np7%252BUoWsr1SFIUxZNLIelf9qWe7mZLtJ2l3bbZy4VSVLAA%3D%3D
	Sockets decoupling
	https://www.digikey.sg/products/en/connectors-interconnects/sockets-for-ics-transistors/409?k=&pkeyword=dip+decoupling&sv=0&pv5=382168&sf=1&FV=589%7C405002%2C-8%7C409&quantity=&ColumnSort=0&page=1&pageSize=25
	Same decoupling socket, found using manufacturer part number
		https://www.digikey.com/product-detail/en/mill-max-manufacturing-corp/110-93-314-41-801000/ED2101-ND/33731
		https://www.mouser.sg/ProductDetail/Mill-Max/110-93-314-41-801000?qs=%2Fha2pyFaduiAoJI%252BFT3Un6AU4u1EPWQWyNo%252BHzE50tJ%252B9XjMyXXSECwGDt8yOlKj
	Digikey might be a better source?
		https://www.digikey.sg/products/en/integrated-circuits-ics/logic-gates-and-inverters/705?k=74ls27&k=&pkeyword=74ls27&sv=0&pv69=411897&sf=0&FV=-8%7C705&quantity=&ColumnSort=0&page=1&pageSize=25
		https://www.mouser.sg/ProductDetail/Texas-Instruments/SN74LS27N?qs=sGAEpiMZZMutXGli8Ay4kP28D9wZ8SQIwsPDjIqEADE%3D
	Digikey has memory
		https://www.digikey.sg/products/en/integrated-circuits-ics/memory/774?k=&pkeyword=&sv=0&pv69=411897&sf=1&FV=-8%7C774&quantity=&ColumnSort=0&page=1&pageSize=25
		But no price: https://www.digikey.sg/products/en/integrated-circuits-ics/memory/774?k=&pkeyword=&sv=0&pv142=227740&sf=1&FV=-8%7C774%2C69%7C411897&quantity=&ColumnSort=0&page=1&pageSize=25
		Jameco has: https://www.jameco.com/shop/ProductDisplay?catalogId=10001&langId=-1&storeId=10001&productId=38957
			Faster: https://www.jameco.com/z/2114N-2-Major-Brands-IC-2114N-2-SRAM-1Kx4-DIP-18-pin-200ns_38973.html?CID=MERCH


* Reorganise the memory map detection logic, remove 3M:A for ROMs, 3M:B 4M 5M 2S:B 1C:A
	Add new memory block detection for _9800CS, _9A00CS, _9C00CS, _9E00CS
	Use a memory block that is not used by the expansion RAM, perhaps the BASIC ROM area
	Check the CPU memory expansion, BUSDDR or CPUHASBUS can also be used to improve the memory block chip detection
	


* For integration with the TTL 8 bit CPU the VSYNC signal could be exposed to EXPANSIONBUS:EXTWANTIRQ
	Remove extra unused logic E7P:A E7P:B E6P:C 5P:A
	This will need a latch arrangement similar to the CPU latch, no use holding EXTWANTIRQ low for so long without being acked
	CPU->Root sheet 8->U250:A
		CIA1 read ACK U201:A



* Allow the _HSYNC and _VSYNC to be read via the external header, as memory mapped IO. Probably reuse the number of sprite register see _9A00CS
	This would need _MERD to be added to the external header. Also the BUSDDR would need to be used to enable the correct tri-state output
* Allow RH AND RV to be accessed via memory mapped IO
	
	
	



* The expansion bus and the memory write signals will need to be translated to the internal memory write signals




	
* 4C/4D when run at 6MHz will generate "sub optimal write pulses" errors with default values. Running at 1MHz fixes these issues.
	* The output pixel data seems to be better when the timing is reduced.
	* Investigate the output for read/write timings of these memory ICs for 6MHz operation.

	
	
* There is also the possibility to allow the horizontal pixel clock and/or the vertical raster position to be read via a latch and suitable address chip enable logic of an 8 bit latch

	



* How many layers? Six?
	https://www.allpcb.com/6_layer_pcb.html
	http://referencedesigner.com/books/si/6-layer-stackup-ch6.php



* All the very similar block, for the new RAMs and also the pixel shift outputs, could use a sub-circuit now
	Since they are RAM addressed and the ROM with its associated data file in the schematic is not important
	If the RAM/ROM names are still important, then have them outside of the sub-circuit



* How about lo/hi registers for tile background char address offset to enable hardware scrolling?
	


* Split this layout so that different output planes can be added or removed via internal headers, daisy-chained probably.
	The final combination logic can then take the output pixels and combine the final result via the pallet lookups
