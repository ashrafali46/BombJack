* Output video signal with resistor ladder. Exclude from simulation once analog behavior has been verified.



* Removed duplicate component references that were causing incorrect auto router errors.



* Sheet 8 - Palette read/write logic



* Need a VSM model for a display that takes digital RGB + HSYNC + VSYNC
	https://github.com/MockbaTheBorg/VSMModel
	https://www.edaboard.com/showthread.php?188054-Creating-A-New-Component-(DLL)-For-Proteus-VSM
	http://fractale.gecif.net/si/logiciels/proteus/ProteusVSMSDK.pdf
	https://github.com/Pugnator/openvsm
	http://pugnator.github.io/openvsm/vsm__api_8c.html

	
	
* Interesting logic with _9A00CS 7R 6R 6S 5R 5S as it is only taking DB0-3 which implies a value 0-15 only. Hmm.
	Resulted in discovering new 0x9a00/0x9a01 functionality for sprite size select, documented in README.md

	
	
* For integration with the TTL 8 bit CPU the VSYNC signal could be exposed to EXPANSIONBUS2:EXTWANTIRQ
	This is because memory writes to 0x98xx can only be made when the video HW is not accessing the sprite regs

	
	
	
* Examine bus SREAD for the timing of sprite reads corresponding to the BH pixel clock and pixel output timing during the scan
	Done - Examine when the scan RAMs get cleared before sprite rendering
	Find out the reason for the first few bytes of what looks like odd data being written even when sprites are not at that coordinate?
