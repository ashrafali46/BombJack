* Output video signal with resistor ladder. Exclude from simulation once analog behavior has been verified.



* Removed duplicate component references that were causing incorrect auto router errors.



* Sheet 8 - Palette read/write logic



* Need a VSM model for a display that takes digital RGB + HSYNC + VSYNC
	https://github.com/MockbaTheBorg/VSMModel
	https://www.edaboard.com/showthread.php?188054-Creating-A-New-Component-(DLL)-For-Proteus-VSM
	http://fractale.gecif.net/si/logiciels/proteus/ProteusVSMSDK.pdf
	https://github.com/Pugnator/openvsm
	http://pugnator.github.io/openvsm/vsm__api_8c.html

	
	
* Interesting logic with _9A00CS 7R 6R 6S 5R 5S as it is only taking DB0-3 which implies a value 0-15 only. Hmm.
	Resulted in discovering new 0x9a00/0x9a01 functionality for sprite size select, documented in README.md

	
	
* For integration with the TTL 8 bit CPU the VSYNC signal could be exposed to EXPANSIONBUS2:EXTWANTIRQ
	This is because memory writes to 0x98xx can only be made when the video HW is not accessing the sprite regs

	
	
	
* Examine bus SREAD for the timing of sprite reads corresponding to the BH pixel clock and pixel output timing during the scan
	Done - Examine when the scan RAMs get cleared before sprite rendering
	Find out the reason for the first few bytes of what looks like odd data being written even when sprites are not at that coordinate?

	
	
* Add page 6 character screen logic



* Complete page 8 pixel combination logic
	page 8 - For the 153x4 ICs D3 seems to be left to float high. Which means, for those pixels it will be floating up to the last entry in the palette.
	Added a push button to cause the D3 input to be lo or high producing a nice debug purple rendering option.
	
	
* Page 7 background picture logic done



* Inspect original PCBs and look for 74 LS/HCT types to match with where possible
	https://www.jammarcade.net/tag/bomb-jack/
	https://www.jammarcade.net/images/2019/06/Arcade-DIY-46-Bomb-Jack-pcb-repair-14-19-screenshot-768x432.png
	Indicates that M74LS174P is 8B (174x2) should suffice

	
	
* _MEWR needs to be connected to the header, might need invert?
	No need an invert, active low

	
	
* To interface with the CPU, the _9800CS and _MEWR lines can be used without any more tri-state buffering, since they are not driven by the video circuitry



* 6MHz clock needs a full can oscillator part in the schematic (disabled for simulation) and layout
	12MHz Can oscillator
	https://www.mouser.sg/ProductDetail/CTS-Electronic-Components/MXO45HS-2C-12M0000?qs=sGAEpiMZZMt8zWNA7msRCvpTgpVI8f3UwUWPm0GFK9s%3D
	Needs the signal and not signal created
	DIP-8 https://www.mouser.sg/datasheet/2/96/008-0258-0-786357.pdf
	
	12.096MHz Short crystal
	https://www.mouser.sg/ProductDetail/ECS/ECS-121-S-4X?qs=sGAEpiMZZMsBj6bBr9Q9aQVbz5FLOGxj6PWo6GSXrZU%3D
	https://www.mouser.sg/datasheet/2/122/hc-49usx-791.pdf
	12.096MHz Tall crystal
	https://www.mouser.sg/ProductDetail/ECS/ECS-121-S-1X?qs=sGAEpiMZZMsBj6bBr9Q9aQVbz5FLOGxjBlVr3Wwx1PM%3D
	https://www.mouser.sg/datasheet/2/122/hc49ux-88.pdf
	
	Added JP1 to select between crystal output from 4T pin 5 when connected, or can oscillator VIDCLK when disconnected
	R1 and R2 from schematic top left page 3 are labelled R21 R22 in Proteus schematic
	
	Same as OSCCLK for CPU project, root sheet 2
	Check original schematic for inverse signal generation, it might have some offset skew
	* Schematic sheet 3, top left, shows a 12.096MHz crystal driving a 7474 dual edge-triggered flip-flop and generating _6MHz 6MHz and .6MHz
		But in the design I used .6MHz and 6MHz as the same thing, logically they are the same
		The inverted output comes from the 74368 hex buffer inverting tristate outputs
	* Added VIDCLK signal and 3T:A and hex inverted drivers 4T
	
	Breadboard https://www.mouser.sg/ProductDetail/Twin-Industries/TW-E41-1060?qs=sGAEpiMZZMvxYGX2LOb%252BCkpSd%2FF6Zib6rdOv%2FJq26CY%3D

	
	
* Regarding 6MHz from 4T, the trace is very long. Perhaps this is why .6MHz was created in the original schematic?
	6N2:B root sheet 6 (6N 456 page 6 bottom middle left)

	
	
* Change screen colours to exercise the 6N2:B flow



* Perhaps move the edge connectors up the board to improve component auto place?



* Instead of using ROMs, use RAMs and add extra logic to enable their write via the external header.
	* Will need 74245
	* To free up the cartridge port, think about perhaps a non-memory mapped interface, so something via the C64 user port?
		https://www.c64-wiki.com/wiki/User_Port
			* The edge connectors have 3.96mm pitch (distance between contacts) and accept cards (PCBs) 1.57mm thick.
		https://coronax.wordpress.com/2012/08/11/the-commodore-64-user-port/
		https://csdb.dk/forums/?roomid=11&topicid=19759
			/PC goes low for one cycle after port B access.
		http://www.devili.iki.fi/Computers/Commodore/C64/Programmers_Reference/Chapter_6/page_359.html#User
			Looks like I can have 8 bits output with PC2 signalling when it's written
				FLAG2 as input for VSYNC (NMI trigger or poll DD0D bit 4)
				PA2 as an output bit flag
			So on PA2 this can reset the state to reading a lo/hi address, then any number of bytes to store without needing the number of bytes
				C64Docs\C64PRG10_TXT.txt
					DD00
					2      RS-232 Data Output (User Port)
					DD02       56578                 Data Direction Register - Port A
					PA2 is bit 2 of PORT A of the CIA
	* Need to find out how much RAM will be needed and decide a memory map
		All the used *.bin files (mapped into ROMs) total 64K of data.
		This means a linear 16 bit address bus model won't work as there isn't space for the RAM to be mapped.
		Instead, the ten!! ROMs can be selected with an explicit chip select register combined with an address, so 24 bits instead.
		byte:
			0		Chip select using a 74154 to map up to 16 chip groups
			1/2		Lo/hi address setup
			3		Bytes to store, address++
		Done: UserPortTo24BitAddress
			Done: U6-U9 needs to load the lo/hi address as needed, when they are selected and on the negative edge of _PC
					RCO goes to ENP&ENT
					CLK needs to cause the address to count up on the positive edge of _PC and only when U10 is being populated with CS3 low.
			* U3, U10, U18 and U19 contain the chip select, data, addr lo/hi with auto increment
			Done: EMEMWRITE will need to be low for a short tick while after the data/address are stable
				Perhaps add logic to toggle this based on a delayed flip-flop chain?
				* Actually just used the after byte tick instead
				* Added a quick debug selector and RAM, to visually display the memory can be selected and written
			Done: EXTWANTIRQ, from the _VBLANK negative edge when it starts the VBLANK will need to be sent to FLAG2 (which is negative edge triggered on the C64)
		* 74154 Obsolete!?
			74139 used instead
			74138 is also available
	* 4T on sheet 3 which creates the 6MHz/.6MHz/_6MHz signals from the input VIDCLK has OE
		This output enable could be tied to a register line to enable or disable the whole display, which would massively help with writing to any RAMs for the video data.
		This could be the higher bits of 9e00?
			Root sheet 7, 4S7 could store the extra bits if it was rewired a bit. Default is low, so no video output?
			3S+3R could also be reset on low
			* Added DB5 line for 0 = disable display and 1 = enable (DISPLAYENABLE and _DISPLAYENABLE)
				This allows large amounts of data to be written to RAM while the display is disabled without fear of contention with the display HW
	* ROMs will need RAMs, the memory setup timings will need to be honoured.
		The original RAMs can be selected as per normal and can be the first line, suitable _CSEN+_MREQ can be faked for those.
			Inverted EBS0 perhaps?
		The other lines can enable or disable the ROM->RAM segments as needed with perhaps 2-3 8K chunks memory mapped on each line
			74LS245 plus 74157
	* Done: User port (write memory) timings, need to honour the expected timings for address and data setup
		Check with the logic analyser
			EMEMWRITE might not have the correct setup timing constraints
			There should be the memory and data setup, then a delayed write pulse (low) where the data and memory is still setup afterwards
				Might be because _PC is timed wrong on the input simulated data?
					* Done: Yes, the signals need expanding a bit more to include the leadin and leadout states
					* Done: Check leadin and leadout states on CIA timing diagram with _PC and data levels
						* BombJack loads 4S7 (root sheet 7) on the positive edge (trailing edge) of _MEWR with a low _9E00CS and 7432 (OR) output
							This makes sense since it might be trying to accommodate timing issues where the data might be settling during RAM cycle timing
						* Done: So update userport design to also accommodate this
							Memory and data are primed, _MEWR is held low for a short pulse, memory and data still held
							Verified by logic analyser
	* Done: Attempt RAM replacement for Root sheet 7. Read only background picture logic
		4P7 2764 can be replaced with a 6264
			_CE will need a low to select
			CS can be high all the time
			_WE low on _MEWR
			_OE low on memory read
			To select address perhaps a 74157 with _A/B based on _ADDRCS? With _ADDRCS OR (7432) _MEWR going to _WE
			74245 needed for bus tristate?
				Or maybe a simple 74373 for tri-state outputs since we don't need read logic
				The 6116 RAM on root sheet 6 has interesting _OE/_WE based on a simple NOT 7404
		* 4P7R (RAM) replaces 4P7, BusEBS.ptn added to simulate "Root sheet 7 EBS7 EA13 RAM select"
			There are some logic contentions on BIDxx at the start, but similar CID contentions are also seen on 6LM6 RAM writes from the original schematic
			* 4P7 has been schematic and placement disabled
			* 4P7R is obviously enabled
			* Only memory from 02_p04t.bin $400 to $5ff is included in the pattern file, to reduce the data specific to the sphinx graphics
				It is $100 bytes of char data, followed by $100 bytes of colour data
	* Done: Will need a replacement for the Proteus data generators because they have a 1024 byte limit
		VSMDD2 on root sheet 1 now uses TestData.txt to set all the data needed
	* Done: Root sheet 7 8R7 using 08_r08t.bin to RAM	EBS6 EA14 RAM select	$2000
	* Done: Root sheet 7 8N7 using 07_n08t.bin to RAM	EBS6 EA15 RAM select	$4000
	* Done: Root sheet 7 8L7 using 06_l08t.bin to RAM	EBS6 EA13 RAM select	$8000
	Note all new logic for the RAMs on root sheet 7. The original ROMs are still present, just disabled from the simulation and layout.
	
	* Character data
	* Done: Root sheet 6 8K6 using 05_k08t.bin to RAM	EBS5 EA14 ram select	$2000
	* Done: Root sheet 6 8H6 using 04_h08t.bin to RAM	EBS5 EA15 ram select	$4000
	* Done: Root sheet 6 8E6 using 03_e08t.bin to RAM	EBS5 EA13 ram select	$8000
	
	* Sprite data
	* Done: Root sheet 4 7J using 14_j07b.bin to RAM	EBS4 EA13 ram select	$2000
	* Done: Root sheet 4 7L using 15_l07b.bin to RAM	EBS4 EA14 ram select	$4000
	* Done: Root sheet 4 7M using 16_m07b.bin to RAM	EBS4 EA15 ram select	$8000



* Group EBS usage for the tile/char/sprite data to EBS6/EBS5/EBS4 so that all three available 8K banks are in the same EBS



* Remove the vertical flip button and associated logic? Since it's not really needed as I'm not strictly emulating an arcade board any more.
	The layout complexity can instead be used for pixel level scrolling and the extra timing generation

	
	
* Background layer (root sheet 7) pixel fine scrolling enable?
	Could have an extra register $9e01 (l/h nybbles for x/y) that add values 0-15 to the X/Y pixel clock before addressing the background data?
		This could in effect generate a pixel scrolled background image?
	* For 6S7 and 5S7 timing
				cba9876543210 = Address at 4P7R/4P7
		_SL2	0010010100111
		4x6MHz clocks
		_SLOAD	0010110100111
		4x6MHz clocks
		_SL2	0010010101000	*
		4x6MHz clocks			*
		_SLOAD	0010110101000	*=
		4x6MHz clocks			*==	One 16x16 tile being loaded, character/tile index then colour
		_SL2	0010010101000	*=
		4x6MHz clocks			*
		_SLOAD	0010110101000	*
		4x6MHz clocks			*
		_SL2	0010010101001
	* Signals that need handling: XXH' and XXV' plus 4H, SLOAD and _SLOAD (which trace back from BIS0)
		Added new signal prefix BGH for these by copying the logic from root sheet 3
		Initial tests of the X nybble write seem to indicate success!
	* TODO: At this point, could do with a DigitalData wait for edge (for _VBLANK) and output new data code
	* X and Y pixel scroll logic added

	
	
* Need some extra logic (and control bit) to hide the gaps behind slightly contracted borders (just like the C64)
	U65 has spare two bits 6/7, if 1 then contract the Fair right and bottom borders respectively
	X & Y Border shrink works





* When running at VIDCLK 6MHz, the target speed, the sprites fail to render correctly.
	This is because Root sheet 5 4A/4B/4C/4D/ have by default 200ns address access time.
	They are 4 bit RAMs, obviously the original hardware was slightly exceeding the 166.6 ns timing from the 6MHz clock
	Verified that if the default 200ns is changed to be 100ns then the sprites start displaying again
		* It is interesting to note 8K replacement 6264 RAMs are all 100ns address access time
	They only use A0-A7 internally
	Consider using 8 bit RAMs with lower access times instead
	The next viable RAM would be: https://www.jameco.com/z/6116P-70-Major-Brands-IC-6116P-70-CMOS-SRAM-16-384-Bit-2Kx8-70-ns_242675.html
		This can be simulated and it is still able to be ordered.
	Running a 12 MHz VIDCLK with 70ns address access time results in some corrupt sprites at their correct positions
		Running with 10 MHz VIDCLK (49.2 FPS) means the sprites render correctly.
		With 50ns address access time the sprites render correctly.
		(See Root sheet 5 with 6116 RAM for sprite spans for an example)
	* TODO: Split the 2114 RAMs into two or more, based on their low address, to interleave the bit accesses
		Might have to latch the address and data to hold the address and data for longer, have 2 or 4 latches?
		This latches will need to use the low address lines to decide which chip to enable for read/write
	http://www.cs.smith.edu/~jfrankli/270s02/datasheets/2114.html
		Note: No address setup time
	http://www.ukvac.com/forum/bomb-jack-pcb_topic368665.html
	* TODO: Study the memory, data and WE access patterns to plan for the best strategy
		From about 1.33 seconds into the simulation will be the middle of the frame
		Note: VSMDD3 on root sheet 5 setup to record the:
			Address
			Byte
			D24 _write
			D30 0 = Output pixel data to the screen and clear to ff, 1 = reading/writing sprites
			D31 _CE
			Clock start time 1.33
		Note: 4C4DRecording.txt
		Note: The first few thousand lines were trimmed to align with the start of the d$4 phase
		d$0 indicates _CE and outputting pixels to the screen
			So the following:
				d$0100ff08
				d$01006f08
				d$00006f08
				d$0000ff08
				d$0100ff09
				d$01006f09
				d$00006f09
				d$0000ff09
			Note the address counts up, reads, then quickly writes ff, note the data is not stable during the _WE
		d$4 indicates writing sprite data
			Using TestData.txt "Top left all the same" it's possible to see the same address range 0-f repeatedly being used
			4D (ID4-7) starts to get 77...
			4C (ID0-3) still shows ff...
			So the following:
				d$4100ff00
				d$4000ff00
				d$40007f00
				d$41007f01
				d$4100ff01
				d$4000ff01
				d$40007f01
			Indicates that the RAM will consume the written data even after the 6MHz negative edge, basically when it's low
				However note that the address is stable
		Perhaps on _WE, the relevant latching address hold and write hold can hold the WE low for the relevant RAM whilst the new address switches to its read mode
		Once the address switches to read mode the WE is not held low
		* In Test2114 project, using the 10MHz VSMDD3 recording only half of the bytes are visible in the 2114s
		* Now the VSMDD3 clock is at 100MHz, now the 2114s do show both halves are written to.
			It shows there is some high-frequency interaction going on that needs study.
			Which is visible in the recordings:
				d$0000ff00
				d$0100ff00
				d$0100ff01
				and
				d$40007f00
				d$41007f00
				d$41007f01
			Note the very quick (<10ns) write address 0, then read address 0, then read address 1
		* 4C4DRecording output pixels.txt
			Been created to start with pixel output and clear
		Note however the high frequency variance in address lines:
			d$41007f01
			d$41007f03 <<<
			d$41007f02
		Probably due to 6C/6D 74163 counters displaying a non-stable ripple output
			Solved by adding U77/U78 74273 that use _VIDCLK for CLK to latch the address inputs a short time after the counters have finished
				See StableSpriteScanAddress.png
			Note the recording now shows a stable address lagging behind 21/22 lines (210/220 ns) plenty of time for the signals to settle
			Visually the output sprite pixels do seem to be a little bit better formed, more regular
			Unfortunately, this latch lag means even VIDCLK at 4MHz shows the "purple bars" corruption, due to the late arriving address compared to the data
			Without the "fix" at 4MHz the sprites display correctly.
		https://www.mouser.sg/Semiconductors/Logic-ICs/Logic-Comparators/_/N-cbost?P=1z0y33v&Keyword=74ls688&FS=True
		* Test2114
			* TODO: If _6MHz (writing) and IDA0 then use memory, memory _WE needs to be held low for longer than _6MHz, enable write latch signal, also latch data to write to memory, also U2 load address and U9 load data, and output enable U9 for cached output
			* Done: If 6MHz (reading) and IDA0 and IDA=C0A then bypass memory and output enable U9
			* TODO: If 6MHz (reading) and IDA0 and IDA!=C0A then use memory, bypass U2 and U9, select raw memory signal 74257, reset any write latch for memory and output enable select memory
		* Going back to testing the 2114 chip access timing profile:
			With the Proteus defaults then 6M is about the limit, however using 2114AL-1 values ( http://www.cs.smith.edu/~jfrankli/270s02/datasheets/2114.html )
				{TAA=100ns}
				{TCE=70ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
			Then 8M is the limit (with a single pixel vertical line duplicating the background near the right hand edge)
			With 9MHz no sprite data is visible, then changing to use:
				{TAA=100ns}
				{TCE=10ns}
				{TOE=10ns}
				{TOD=10ns}
				{TWP=10ns}
				There are only some bad pixels, but hardly anything visible.
				Instead changing to use:
				{TAA=75ns}
				{TCE=70ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
				All sprites are visible correctly again. It seems as though the TAA access time is what is important.
				The above takes the VIDCLK up to 10.5M. At 11M there is a purple vertical bar near the top left edge, but most sprites are still visible.
				At 11M using:
				{TAA=70ns}
				{TCE=50ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
				All sprites are correct.
				At 12M some sprites display doubling or missing line corruption.
				Using this:
				{TAA=60ns}
				{TCE=50ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
				All sprites are fine at 12M = 59.2 fps
				10.1M = 49.8 fps
			Back to 2MHz and all is well. Test2114 indicates that a write through caching version of a 2114 would work as a daughter board to the 2114 socket, if needed.
			The unstable addresses from the counters could be handled by more than two cached lines. In the real hardware they may cause spurious reads or writes in the RAMs.
			So for now continue to assume that modern real world 2114s are as fast as those used in the original hardware decades ago.
			The Proteus 2114 model could do with some checks to see how fast it really can write according to finely controlled timings.

			
			
* Use the DigitalData negative edge wait to add a horizontal scroll test




* Demo animation for sprite and scrolling
	TestData.txt updated to include display register updates for each frame
	cd /d C:\Work\BombJack\output
	c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp debug.gif && debug.gif
	c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp debug2.gif && debug2.gif
	For the hires schematic: c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp -resize 768x528! debug.gif
	This demonstrates horizontal and vertical pixel scrolling, using a variation on the original Bomb Jack hardware. Extra screen banks are updated into the new graphics RAM to update the tile positions. One sprite is updated too.

	
	
	
* Double check the exact input clock rate and logic with the original schematic for running at the required frame rate
	12.096MHz

	
	
* Replace the 2114s with a single 6116
	Here we have very fast memory: https://www.mouser.sg/Semiconductors/Memory-ICs/SRAM/_/N-4bzpt?P=1z0z63x&Keyword=6116&FS=True
	* Going back to testing the 2114 chip access timing profile
		With the Proteus defaults then 6M is about the limit.
	* With 6116 defaults then 8MHz is about the limit
		However 20ns access time can be found: https://www.mouser.sg/ProductDetail/IDT/6116SA20TPGI?qs=sGAEpiMZZMt9mBA6nIyysK6VW3GrAnba45Kc6Apw0Go%3D
			* https://www.mouser.sg/datasheet/2/464/IDT_6116_DST_2014115-882651.pdf
	* Using these speeds in Proteus:
		{TAA=19ns}
		{TCE=11ns}
		{TOE=10ns}
		{TOD=8ns}
		{TWP=12ns}
	* The old 2114 4A,4B,4C,4D have been disabled/excluded and replaced with two 6116 U77 U78 instead

* Auto place OK



* Using the logic analyser, measure the _VSYNC and _HSYNC timings and compare between the original at 12.096 MHz and the higher resolution version at 24.192 MHz
	A2	_HSYNC
	A3	_VSYNC
	A5	VBLANK
	Logic analyser capture on _VSYNC (A3) positive edge
	Using 2u capture resolution.
	From the original schematic:
	First A3 negative edge 16.25 mS
	Next A3 negative edge 33.02 mS
	First A5 negative edge 1.02 mS
	Next A5 positive edge 15.24 mS
	Next A5 negative edge 17.78 mS
	A5 positive edge to negative edge 2.54 mS
	A3 positive edge to A5 negative edge 1.02 mS
		A2 negative edges between 16
	A2 negative pulse length 16 us
	Negative edge A5 to negative edge A2 8 uS
	A2 positive edge to positive edge 64 uS

	
	
	
* With faster sprite RAMs being used, it might be possible to expand the horizontal resolution of the whole screen to be 512 pixels :D
	Extra bytes would be needed, $9900 or $9a00 and extra 2114 RAMs to load in parallel to the high-X pos value load per sprite
		Maybe use bit 4 from "Byte 1: HV..CCCC" for this? 6E or 7E could latch it?
	Initial tests of adding an extra bit to the H values works quite well.
	At 24.192MHz then 3E and 3F need to be made faster, replace with 6116 instead?
	The timing for sprite register colours is quite tight though. Also there is going to be extra memory needed for the char screens.
	Reverted the change for now, needs more pondering.
	* First change all references to *256H* to be *512H*
	* Change *ZZZH* to *512H*
	* Then create the _512H to 512H circuit
	* And tackle the HBLANK timing test
	* Tweak background address lines to reduce the number of screen but increase the horizontal resolution using 256H/512H as appropriate
	* Add extra sprite scan address line
	* Add extra sprite registers address lines
	* Add extra byte for MSB for each sprite from $9900, to be loaded when the sprite X pos is loaded
	* 6LM6 6116 needs to be a 6264 for the AB11 and to use 256H' the lower address bits will need to be shifted up
	* Test project: Bomb Jack 512x256 test 48 sprites.pdsprj
	* Sprite and char screen logic done
	* Done: Tile screen logic, there will need to be some 256H handling to addresses as it is currently missing
	* TODO: Instead of VIDCLK = 24.192 MHz going into the 3T:A 7474, could instead use VIDCLK directly into 4T
	* Done: Sprite register 3E/3F loading address is different in hires compared to lores?
		Yes, they start at $9840 not $9820 according to the logic analyser
	* 6264
		https://www.mouser.sg/ProductDetail/Alliance-Memory/AS6C6264-55PCN?qs=sGAEpiMZZMt9mBA6nIyysDfDw0vDQxSwL3Jgh6owPVw%3D
		https://www.mouser.sg/datasheet/2/12/Alliance%20Memory_64K_AS6C6264v2.0July2017-1144693.pdf
		{TAA=55ns}
		{TCE=55ns}
		{TOE=30ns}
		{TOD=20ns}
		{TWP=45ns}
	Created 2114FAST, 6116FAST and 6264FAST to reflect timings in datasheets and empirical values for 2114
	* Done - 3E/3F could use one 6116 instead
	* TODO: There is a strange sprite colour corruption when running at VIDCLK = 24 MHz
		Output from 7E and input to 6E matches
		Output from 6M MV0-3 is sometimes out of sync
			Tried configuring very fast RAMs 7JR 7LR 7MR did not fix the issue
			TODO: Signals going into the above RAMs? Use VSMDD5
			VSMDD6 shows O0..7 is OK
			VSMDD5 shows C0..12 is sometimes wrong
				Which bits are mostly wrong?
				C0..4 are OK
				C5..8 are sometimes wrong, which?
					C5 always 0 when wrong at 24 MHz
						MD0 or 16MH? S?
							S seems to be late sometimes?
								5R or 5S late/wrong at high speed? Disable and test. Does not seem to fix the issue.
				C9..12 are sometimes late, but no wrong signals detected
	* TODO: At the moment it looks like the timing is too tight for 512x256 hires

	
	
* Update the standard resolution schematic to use 2114FAST, 6116FAST and 6264FAST
	Test with 12.096 MHz VIDCLK

	
	
* Standard resolution: 3E/3F could use one 6116 instead



* Disable 5F and the screen fills with sprite data, this obviously disables the Y pos range check.
	This could be easily configured with a sprite Y pos test register bit to allow full height sprites with repeating patterns.
	3E/3F are the sprite register RAMs, it's possible to read extra data from $9900- and an extra RAM to feed this daft idea cheaply
	Maybe use bit 5 from "Byte 1: HV..CCCC" for this? 6E or 7E could latch it?

	
	
* Last plane, it's a latch for pixel colour from palette
	Can up dated during screen time by a copper
	Use similar for $01 $9e03 to store this?
	* Added U81 for BBCL0-7

	
	
* 4 bit adds for tile plane ($9e02)
	The demo has been updated to use this instead of duplicating the screen data in different banks with a shift

	
	
	
* There is also the possibility to allow the horizontal pixel clock and/or the vertical raster position to be read via a latch and suitable address chip enable logic of an 8 bit latch
	* Alternatively, have a "copper" mode on the interface logic board?
	* To test this, the digital data part can be expanded to accept more inputs for RH and RV, no need for _HSYNC with this remapping model
	* Done: Need wait for X/Y pos in DigitalData, added some test data patterns for copper bars and split sprites

	
	
* To get multiplexed sprites working, the sprite logic seems to need to be disabled to avoid spurious data bus reads
	Or the data bus writes need to be precisely timed, with a proper copper, to coincide with periods where the sprite registers are not being read
	See: TODO: While this works, it needs a proper copper



* Alternatively, have a "copper" mode on the interface logic board?
	* The mapping of the RH and RH values and CLK to a header could allow RAM to output defined signals to the ED, EA, EBS output.
		The RH values could be divided down to only trigger during _HSYNC for example
		Or it should be possible to program a "mapping" memory for RH and RV, that defines when/how the real "copper" memory can be accessed.
			This could translate into addresses that are logically ORed into a final lookup address into the copper.
		This could be selected by a particular EBS mode, perhaps even the idle 0x00 or maybe the 0x02 mode?
		Setup of this memory will have to be done during the _VBLANK to avoid visible artefacts, writing takes priority.
		* TODO: Idle EBS mode would be good, the user port interface can be tweaked to disable all outputs to DB/AB/EBS etc when EBS == 0
		* TODO: Digital data would need an output disable mode for certain pins, the copper could then be added as real extra logic from the main board
			* EBS would obvious need to be maintained as output with 0 to stop the whole board chip groups being selected at once
			* Or to emulate, the DigitalData could have an extended output value command that accepts override data setup and _MEWR timings
		Old DigitalData clock=500k
			TOLOW=0.00000025
			TOHI=0.0000005
		Now using clock=2M
			TOLOW=0.000000125
			TOHI=0.00000025
		* Note: At 2M the sprite multiplex split is very small and does not interfere much with the video output
			* This means it might still be possible to emulate and find safe spots for the sprite register writes, needs experimentation
			* There are no safe spots, the sprite RAM is constantly read during the scan frame
				$9a00 Upper nybble: $10 = Enable sprite output (6S SPREN), works by resetting the contents of the sprite shifts on low
			* Success! Examining the rendered output the tall stretched sprites not yet updated are visible without artefacts

			
			
* Investigate latched writes to the background colour. It's not entirely stable if the copper bars move up and down?!
	* A double write to "d$9e0301XX" seems to fix the issue? Is this because the address should be maintained, not incremented?
		Or is it the horizontal timing position that is just right?
	* Perhaps, a second sprite register RAM can be used, while one is being read the other can be written to?
		Perhaps not, it would need quite a bit of extra logic to isolate the DB and AB
	* Fixed a bug in DigitalData where waiting for an input value caused the first value to be skipped
	* Double writes removed from the data generator, the display still renders correctly


	
	
* Introduce extra colours bars.
	TODO: Some of the frames show some colour bar sparkles visible on the left of the screen in the blue area of the scrolling top screen?
		Why? How?
		Shifting the first colour change on the left over 32 pixels seems to have vastly reduced, but not entirely removed the problem.
		Might it be one of the colours from the last or first segment? It seems to move with the bars?
		* Test a full run without auto-increment addresses during the colour bars
			Sparkles still happen.
		* Try using this for the first colour bar position: file << "001000" << std::endl;
			With d$9e000120	; Disable the tile screen
			With the DigitalData clock input = 2MHz this shows how interaction with the 12.096MHz video clock introduces some timing variance on the left vertical bar
				Changed the clock to be the Q2 (divide by 8) output from a 74161 and VIDCLK clk input
				This fixes the timing variance on the left colour bar
				TestTileDisableRapidColours.txt indicates this equates to colour changes at precisely every 4 pixels, as expected.
					Useful data for a hardware copper...
		* Using the Q1 (divide by 4) output from the 74161 and the display demo is stable, and rapid colour writes are now at 2 pixels resolution
			Also very useful data for a hardware copper
		* Try running with this new clock input
			Up to frame 275 it all looks clear!
			All frames look clear.


			
			
* 7483 no longer made? Change to 74283 with different pinout.



* GenerateData2
	Add a simple (naive) multiplexor test using WaitForRaster() to then reset the sprite used back to the first if there is enough gap



* Board separation preparation work
	* Need to rationalise and reduce the memory decode logic single pin nets (Design Explorer root sheet 10)
		_WRAM0
		_WRAM1
		_ROM0-4
		_RAM0-1
		WAIT
		_8800CS
		_8C00CS
		Above all removed
	* Using Design Explorer->Net->Type: Single Pin Class: SIGNAL, these are all in need of checking
		BBCL7	Last colour of the "background" colour, U82, part of the tiles board, root sheet 7
				Since this feeds directly into the pixel combinatory logic, then removing the chip would allow the "background" to be set by a mode7 layer etc
		BGHSS	Root sheet 7, it comes from the updated SS related logic from root sheet 3 (for SL1, SL2, SW etc) that generates the background tiles signals with the X/Y scroll values
				SS is used by the character screen, not the tiles, so it is really unused. Removed.
		HBL		Unused, root sheet 3, removed. Not useful like the _HSYNC and _VSYNC, since the copper can read RH0-8 and RV0-7
		ISAB7	Root sheet 4, sprite logic, last unused pixel colour
		_BGHSL1	Unused by the tiles, same as BGHSS origins, from the tiles x/y pixel scroll update. Removed.
		_BGHSW	Unused, same origins as BGHSS and _BGHSL1. Removed.
		_SW		Root sheet 3, unused. Removed.
	* Created _EXTCS8000-B800 lines which can be moved to a header from the main "Video gen, pixel clock timing, final mixing output" board
		Created header INRAMSEL1
		Note: _9000CS renamed to _EXTCS9000
		* _EXTCS9800 logic that decodes the _9800CS, _9A00CS, _9C00CS, _9E00CS duplicated on each board that uses these
			_9800CS root sheet 40	(Sprites)			U86:A
			_9A00CS root sheet 30	(Sprite size logic)	U88:A
			_9C00CS root sheet 80	(Palette)			U87:A
			_9E00CS root sheet 70	(Tiles)				U88:A
	* Merge _CSEN and _MREQ and remove
	* Sprite size logic now moved to root sheet 40

	
	
* Part 7N Outputs... Moved to sheet 50 and and split to sheet 80 (U33)
		_256H*.		Sheet 50
		256H*.		Sheet 50
		1V*.		Sheet 50
		_1V*.		Sheet 50
		_CMPBLK*.	Sheet 80

* SS from sheet 3 1T output 11 was wrong, the 1T 13 input was only connected to 1S 2 input and not connected to 2T 4 output
	SS			Moved to Chars board sheet 60
	_SL1		Moved to Chars board sheet 60
	_SL2		Moved to Chars board sheet 60
