* Output video signal with resistor ladder. Exclude from simulation once analog behavior has been verified.



* Removed duplicate component references that were causing incorrect auto router errors.



* Sheet 8 - Palette read/write logic



* Need a VSM model for a display that takes digital RGB + HSYNC + VSYNC
	https://github.com/MockbaTheBorg/VSMModel
	https://www.edaboard.com/showthread.php?188054-Creating-A-New-Component-(DLL)-For-Proteus-VSM
	http://fractale.gecif.net/si/logiciels/proteus/ProteusVSMSDK.pdf
	https://github.com/Pugnator/openvsm
	http://pugnator.github.io/openvsm/vsm__api_8c.html

	
	
* Interesting logic with _9A00CS 7R 6R 6S 5R 5S as it is only taking DB0-3 which implies a value 0-15 only. Hmm.
	Resulted in discovering new 0x9a00/0x9a01 functionality for sprite size select, documented in README.md

	
	
* For integration with the TTL 8 bit CPU the VSYNC signal could be exposed to EXPANSIONBUS2:EXTWANTIRQ
	This is because memory writes to 0x98xx can only be made when the video HW is not accessing the sprite regs

	
	
	
* Examine bus SREAD for the timing of sprite reads corresponding to the BH pixel clock and pixel output timing during the scan
	Done - Examine when the scan RAMs get cleared before sprite rendering
	Find out the reason for the first few bytes of what looks like odd data being written even when sprites are not at that coordinate?

	
	
* Add page 6 character screen logic



* Complete page 8 pixel combination logic
	page 8 - For the 153x4 ICs D3 seems to be left to float high. Which means, for those pixels it will be floating up to the last entry in the palette.
	Added a push button to cause the D3 input to be lo or high producing a nice debug purple rendering option.
	
	
* Page 7 background picture logic done



* Inspect original PCBs and look for 74 LS/HCT types to match with where possible
	https://www.jammarcade.net/tag/bomb-jack/
	https://www.jammarcade.net/images/2019/06/Arcade-DIY-46-Bomb-Jack-pcb-repair-14-19-screenshot-768x432.png
	Indicates that M74LS174P is 8B (174x2) should suffice

	
	
* _MEWR needs to be connected to the header, might need invert?
	No need an invert, active low

	
	
* To interface with the CPU, the _9800CS and _MEWR lines can be used without any more tri-state buffering, since they are not driven by the video circuitry



* 6MHz clock needs a full can oscillator part in the schematic (disabled for simulation) and layout
	12MHz Can oscillator
	https://www.mouser.sg/ProductDetail/CTS-Electronic-Components/MXO45HS-2C-12M0000?qs=sGAEpiMZZMt8zWNA7msRCvpTgpVI8f3UwUWPm0GFK9s%3D
	Needs the signal and not signal created
	DIP-8 https://www.mouser.sg/datasheet/2/96/008-0258-0-786357.pdf
	
	12.096MHz Short crystal
	https://www.mouser.sg/ProductDetail/ECS/ECS-121-S-4X?qs=sGAEpiMZZMsBj6bBr9Q9aQVbz5FLOGxj6PWo6GSXrZU%3D
	https://www.mouser.sg/datasheet/2/122/hc-49usx-791.pdf
	12.096MHz Tall crystal
	https://www.mouser.sg/ProductDetail/ECS/ECS-121-S-1X?qs=sGAEpiMZZMsBj6bBr9Q9aQVbz5FLOGxjBlVr3Wwx1PM%3D
	https://www.mouser.sg/datasheet/2/122/hc49ux-88.pdf
	
	Added JP1 to select between crystal output from 4T pin 5 when connected, or can oscillator VIDCLK when disconnected
	R1 and R2 from schematic top left page 3 are labelled R21 R22 in Proteus schematic
	
	Same as OSCCLK for CPU project, root sheet 2
	Check original schematic for inverse signal generation, it might have some offset skew
	* Schematic sheet 3, top left, shows a 12.096MHz crystal driving a 7474 dual edge-triggered flip-flop and generating _6MHz 6MHz and .6MHz
		But in the design I used .6MHz and 6MHz as the same thing, logically they are the same
		The inverted output comes from the 74368 hex buffer inverting tristate outputs
	* Added VIDCLK signal and 3T:A and hex inverted drivers 4T
	
	Breadboard https://www.mouser.sg/ProductDetail/Twin-Industries/TW-E41-1060?qs=sGAEpiMZZMvxYGX2LOb%252BCkpSd%2FF6Zib6rdOv%2FJq26CY%3D

	
	
* Regarding 6MHz from 4T, the trace is very long. Perhaps this is why .6MHz was created in the original schematic?
	6N2:B root sheet 6 (6N 456 page 6 bottom middle left)

	
	
* Change screen colours to exercise the 6N2:B flow



* Perhaps move the edge connectors up the board to improve component auto place?



* Instead of using ROMs, use RAMs and add extra logic to enable their write via the external header.
	* Will need 74245
	* To free up the cartridge port, think about perhaps a non-memory mapped interface, so something via the C64 user port?
		https://www.c64-wiki.com/wiki/User_Port
			* The edge connectors have 3.96mm pitch (distance between contacts) and accept cards (PCBs) 1.57mm thick.
		https://coronax.wordpress.com/2012/08/11/the-commodore-64-user-port/
		https://csdb.dk/forums/?roomid=11&topicid=19759
			/PC goes low for one cycle after port B access.
		http://www.devili.iki.fi/Computers/Commodore/C64/Programmers_Reference/Chapter_6/page_359.html#User
			Looks like I can have 8 bits output with PC2 signalling when it's written
				FLAG2 as input for VSYNC (NMI trigger or poll DD0D bit 4)
				PA2 as an output bit flag
			So on PA2 this can reset the state to reading a lo/hi address, then any number of bytes to store without needing the number of bytes
				C64Docs\C64PRG10_TXT.txt
					DD00
					2      RS-232 Data Output (User Port)
					DD02       56578                 Data Direction Register - Port A
					PA2 is bit 2 of PORT A of the CIA
	* Need to find out how much RAM will be needed and decide a memory map
		All the used *.bin files (mapped into ROMs) total 64K of data.
		This means a linear 16 bit address bus model won't work as there isn't space for the RAM to be mapped.
		Instead, the ten!! ROMs can be selected with an explicit chip select register combined with an address, so 24 bits instead.
		byte:
			0		Chip select using a 74154 to map up to 16 chip groups
			1/2		Lo/hi address setup
			3		Bytes to store, address++
		Done: UserPortTo24BitAddress
			Done: U6-U9 needs to load the lo/hi address as needed, when they are selected and on the negative edge of _PC
					RCO goes to ENP&ENT
					CLK needs to cause the address to count up on the positive edge of _PC and only when U10 is being populated with CS3 low.
			* U3, U10, U18 and U19 contain the chip select, data, addr lo/hi with auto increment
			Done: EMEMWRITE will need to be low for a short tick while after the data/address are stable
				Perhaps add logic to toggle this based on a delayed flip-flop chain?
				* Actually just used the after byte tick instead
				* Added a quick debug selector and RAM, to visually display the memory can be selected and written
			Done: EXTWANTIRQ, from the _VBLANK negative edge when it starts the VBLANK will need to be sent to FLAG2 (which is negative edge triggered on the C64)
		* 74154 Obsolete!?
			74139 used instead
			74138 is also available
	* 4T on sheet 3 which creates the 6MHz/.6MHz/_6MHz signals from the input VIDCLK has OE
		This output enable could be tied to a register line to enable or disable the whole display, which would massively help with writing to any RAMs for the video data.
		This could be the higher bits of 9e00?
			Root sheet 7, 4S7 could store the extra bits if it was rewired a bit. Default is low, so no video output?
			3S+3R could also be reset on low
			* Added DB5 line for 0 = disable display and 1 = enable (DISPLAYENABLE and _DISPLAYENABLE)
				This allows large amounts of data to be written to RAM while the display is disabled without fear of contention with the display HW
	* ROMs will need RAMs, the memory setup timings will need to be honoured.
		The original RAMs can be selected as per normal and can be the first line, suitable _CSEN+_MREQ can be faked for those.
			Inverted EBS0 perhaps?
		The other lines can enable or disable the ROM->RAM segments as needed with perhaps 2-3 8K chunks memory mapped on each line
			74LS245 plus 74157
	* Done: User port (write memory) timings, need to honour the expected timings for address and data setup
		Check with the logic analyser
			EMEMWRITE might not have the correct setup timing constraints
			There should be the memory and data setup, then a delayed write pulse (low) where the data and memory is still setup afterwards
				Might be because _PC is timed wrong on the input simulated data?
					* Done: Yes, the signals need expanding a bit more to include the leadin and leadout states
					* Done: Check leadin and leadout states on CIA timing diagram with _PC and data levels
						* BombJack loads 4S7 (root sheet 7) on the positive edge (trailing edge) of _MEWR with a low _9E00CS and 7432 (OR) output
							This makes sense since it might be trying to accommodate timing issues where the data might be settling during RAM cycle timing
						* Done: So update userport design to also accommodate this
							Memory and data are primed, _MEWR is held low for a short pulse, memory and data still held
							Verified by logic analyser
	* Done: Attempt RAM replacement for Root sheet 7. Read only background picture logic
		4P7 2764 can be replaced with a 6264
			_CE will need a low to select
			CS can be high all the time
			_WE low on _MEWR
			_OE low on memory read
			To select address perhaps a 74157 with _A/B based on _ADDRCS? With _ADDRCS OR (7432) _MEWR going to _WE
			74245 needed for bus tristate?
				Or maybe a simple 74373 for tri-state outputs since we don't need read logic
				The 6116 RAM on root sheet 6 has interesting _OE/_WE based on a simple NOT 7404
		* 4P7R (RAM) replaces 4P7, BusEBS.ptn added to simulate "Root sheet 7 EBS7 EA13 RAM select"
			There are some logic contentions on BIDxx at the start, but similar CID contentions are also seen on 6LM6 RAM writes from the original schematic
			* 4P7 has been schematic and placement disabled
			* 4P7R is obviously enabled
			* Only memory from 02_p04t.bin $400 to $5ff is included in the pattern file, to reduce the data specific to the sphinx graphics
				It is $100 bytes of char data, followed by $100 bytes of colour data
	* Done: Will need a replacement for the Proteus data generators because they have a 1024 byte limit
		VSMDD2 on root sheet 1 now uses TestData.txt to set all the data needed
	* Done: Root sheet 7 8R7 using 08_r08t.bin to RAM	EBS6 EA14 RAM select	$2000
	* Done: Root sheet 7 8N7 using 07_n08t.bin to RAM	EBS6 EA15 RAM select	$4000
	* Done: Root sheet 7 8L7 using 06_l08t.bin to RAM	EBS6 EA13 RAM select	$8000
	Note all new logic for the RAMs on root sheet 7. The original ROMs are still present, just disabled from the simulation and layout.
	
	* Character data
	* Done: Root sheet 6 8K6 using 05_k08t.bin to RAM	EBS5 EA14 ram select	$2000
	* Done: Root sheet 6 8H6 using 04_h08t.bin to RAM	EBS5 EA15 ram select	$4000
	* Done: Root sheet 6 8E6 using 03_e08t.bin to RAM	EBS5 EA13 ram select	$8000
	
	* Sprite data
	* Done: Root sheet 4 7J using 14_j07b.bin to RAM	EBS4 EA13 ram select	$2000
	* Done: Root sheet 4 7L using 15_l07b.bin to RAM	EBS4 EA14 ram select	$4000
	* Done: Root sheet 4 7M using 16_m07b.bin to RAM	EBS4 EA15 ram select	$8000



* Group EBS usage for the tile/char/sprite data to EBS6/EBS5/EBS4 so that all three available 8K banks are in the same EBS



* Remove the vertical flip button and associated logic? Since it's not really needed as I'm not strictly emulating an arcade board any more.
	The layout complexity can instead be used for pixel level scrolling and the extra timing generation

	
	
* Background layer (root sheet 7) pixel fine scrolling enable?
	Could have an extra register $9e01 (l/h nybbles for x/y) that add values 0-15 to the X/Y pixel clock before addressing the background data?
		This could in effect generate a pixel scrolled background image?
	* For 6S7 and 5S7 timing
				cba9876543210 = Address at 4P7R/4P7
		_SL2	0010010100111
		4x6MHz clocks
		_SLOAD	0010110100111
		4x6MHz clocks
		_SL2	0010010101000	*
		4x6MHz clocks			*
		_SLOAD	0010110101000	*=
		4x6MHz clocks			*==	One 16x16 tile being loaded, character/tile index then colour
		_SL2	0010010101000	*=
		4x6MHz clocks			*
		_SLOAD	0010110101000	*
		4x6MHz clocks			*
		_SL2	0010010101001
	* Signals that need handling: XXH' and XXV' plus 4H, SLOAD and _SLOAD (which trace back from BIS0)
		Added new signal prefix BGH for these by copying the logic from root sheet 3
		Initial tests of the X nybble write seem to indicate success!
	* TODO: At this point, could do with a DigitalData wait for edge (for _VBLANK) and output new data code
	* X and Y pixel scroll logic added

	
	
* Need some extra logic (and control bit) to hide the gaps behind slightly contracted borders (just like the C64)
	U65 has spare two bits 6/7, if 1 then contract the Fair right and bottom borders respectively
	X & Y Border shrink works
